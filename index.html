<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game Dev Tech Ground - Retro Gritty</title>
  <!-- Include SimplexNoise Library (fixes "SimplexNoise is not defined" error) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/perlin-noise/1.0.0/perlin-noise.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/worley-noise/1.0.0/worley-noise.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js" defer></script> <!-- TensorFlow.js -->
  <style>
    /* website tema*/
    :root {
      --primary-color: #00FF00;        /* Neon green */
      --accent-color: #CCCCCC;
      --background-color: #111111;       /* Deep dark background */
      --hover-color: #FF6600;            /* Neon orange */
      --nav-bg: #000000;                 /* Solid black nav */
      --nav-text: #00FF00;               /* Neon green for nav text */
      --border-style: 1px solid #444444;
      --section-bg: #222222;             /* Dark sections */
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: "Courier New", Courier, monospace;
      color: var(--accent-color);
      background: var(--background-color);
      min-height: 100vh;
      overflow-x: hidden;
      line-height: 1.6;
    }
    /* background neural network tipo */
    #networkCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      background: #000;
    }
    /* Navigation Bar */
    .nav {
      position: fixed;
      top: 0; left: 0; right: 0;
      background: var(--nav-bg);
      border-bottom: var(--border-style);
      z-index: 100;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 15px 20px;
    }
    .nav-button {
      background: none;
      border: none;
      color: var(--nav-text);
      font-weight: bold;
      text-transform: uppercase;
      cursor: pointer;
      font-size: 1rem;
      position: relative;
      overflow: hidden;
      transition: color 0.3s, transform 0.3s;
    }
    .nav-button:hover {
      color: var(--hover-color);
      transform: scale(1.05);
    }
    .nav-button::after {
      content: "";
      position: absolute;
      left: 50%;
      bottom: -3px;
      width: 0;
      height: 2px;
      background: var(--hover-color);
      transition: width 0.3s, left 0.3s;
    }
    .nav-button:hover::after {
      width: 100%;
      left: 0;
    }
    .separator {
      border: none;
      border-top: var(--border-style);
      width: 80%;
      margin: 80px auto 20px;
      z-index: 10;
    }
    .three-section {
      position: relative;
      z-index: 5;
      width: 90%;
      max-width: 1000px;
      margin: 100px auto 40px;
      padding: 20px;
      background: var(--section-bg);
      border: var(--border-style);
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.7);
    }
    .three-section h2 {
      font-size: 2rem;
      margin-bottom: 15px;
      text-transform: uppercase;
      color: var(--nav-text);
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    .three-section h2::after {
      content: "";
      position: absolute;
      left: 50%;
      bottom: -5px;
      width: 0;
      height: 2px;
      background: var(--hover-color);
      transition: width 0.3s, left 0.3s;
    }
    .three-section h2:hover::after {
      width: 100%;
      left: 0;
    }
    .canvas-container {
      width: 100%;
      height: 400px;
      border: var(--border-style);
      background: #000;
      position: relative;
      margin-bottom: 20px;
    }
    .cube-controls, .boids-controls, .terrain-controls, .ai-controls {
      text-align: center;
      margin-top: 10px;
    }
    .cube-controls button,
    .boids-controls button,
    .terrain-controls button,
    .ai-controls button,
    .boids-controls input {
      background: var(--primary-color);
      color: #000;
      border: var(--border-style);
      padding: 8px 12px;
      margin: 5px;
      font-size: 0.9rem;
      border-radius: 2px;
      cursor: pointer;
      transition: background 0.3s, transform 0.3s;
    }
    .cube-controls button:hover,
    .boids-controls button:hover,
    .terrain-controls button:hover,
    .ai-controls button:hover,
    .boids-controls input:hover {
      background: var(--hover-color);
      transform: translateY(-2px);
    }
    .param-group {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 200px;
      margin: 0 auto;
    }
    .param-group label { font-size: 0.9rem; }
    .terrain-stats {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.85);
      padding: 8px 12px;
      border-radius: 2px;
      font-size: 0.8rem;
      border: var(--border-style);
      color: var(--accent-color);
    }
    #easterEgg {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #00FF00;
      padding: 20px;
      border: 2px solid #00FF00;
      border-radius: 10px;
      z-index: 1000;
      text-align: center;
    }
    #easterEgg h2 {
      margin-bottom: 10px;
    }
    #easterEgg p {
      margin-bottom: 20px;
    }
    #easterEgg button {
      background: #00FF00;
      color: #000;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 1rem;
    }
    #easterEgg button:hover {
      background: #FF6600;
    }
  </style>
</head>
<body>
  <!-- Neural Network Background Canvas -->
  <canvas id="networkCanvas"></canvas>
  
  <!-- Navigation -->
  <div class="nav">
    <button class="nav-button" onclick="scrollToSection('home')">Home</button>
    <button class="nav-button" onclick="scrollToSection('cube')">Cube</button>
    <button class="nav-button" onclick="scrollToSection('boids')">Boids</button>
    <button class="nav-button" onclick="scrollToSection('terrain')">Terrain</button>
    <button class="nav-button" onclick="scrollToSection('aiNav')">AI Navigation</button>
    <button class="nav-button" onclick="scrollToSection('about')">About</button>
  </div>
  
  <hr class="separator" />
  
  <!-- Home Section -->
  <section class="three-section" id="home">
    <h2>Welcome to Game Dev Tech Ground</h2>
    <p style="text-align:center;">Retro, Gritty, &amp; Experimental 3D Environments</p>
  </section>
  
  <!-- Cube Showcase -->
  <section class="three-section" id="cube">
    <h2>3D Cube Showcase</h2>
    <div class="canvas-container" id="threeContainer"></div>
    <div class="cube-controls">
      <button id="modifier1">Random Scale</button>
      <button id="modifier2">Random Rotation</button>
      <button id="modifier3">Random Color</button>
      <button id="modifier4">Toggle Wireframe</button>
      <button id="resetCube">Reset Cube</button>
    </div>
  </section>
  
  <!-- Boids Flocking Simulation -->
  <section class="three-section" id="boids">
    <h2>Boids Flocking Simulation</h2>
    <div class="canvas-container" id="boidsContainer"></div>
    <div class="boids-controls">
      <button id="resetBoids">Reset Simulation</button>
      <button id="addBoid">Add Boid</button>
      <div class="param-group">
        <label for="boidCount">Boid Count:</label>
        <span id="boidCount">0</span>
      </div>
      <div class="param-group">
        <label for="perceptionRadius">Perception:</label>
        <input type="range" id="perceptionRadius" min="5" max="50" step="1" value="15">
      </div>
      <div class="param-group">
        <label for="alignmentWeight">Alignment:</label>
        <input type="range" id="alignmentWeight" min="0" max="2" step="0.1" value="1.0">
      </div>
      <div class="param-group">
        <label for="cohesionWeight">Cohesion:</label>
        <input type="range" id="cohesionWeight" min="0" max="2" step="0.1" value="0.8">
      </div>
      <div class="param-group">
        <label for="separationWeight">Separation:</label>
        <input type="range" id="separationWeight" min="0" max="3" step="0.1" value="1.5">
      </div>
    </div>
  </section>
  
  <!-- Terrain Editor -->
  <section class="three-section" id="terrain">
    <h2>Terrain Editor</h2>
    <div class="canvas-container" id="terrainContainer">
      <div class="terrain-stats">
        Vertices: <span id="vertexCount">0</span><br>
        Triangles: <span id="triangleCount">0</span>
      </div>
    </div>
    <div class="terrain-controls">
      <button id="generateTerrain">Generate Terrain</button>
      <button id="toggleWireframe">Toggle Wireframe</button>
      <button id="resetTerrain">Reset</button>
      <div class="param-group">
        <label for="terrainSize">Size:</label>
        <input type="number" id="terrainSize" min="16" max="256" value="64" step="16">
      </div>
      <div class="param-group">
        <label for="terrainRoughness">Roughness:</label>
        <input type="range" id="terrainRoughness" min="0.1" max="2.0" step="0.1" value="0.8">
      </div>
      <div class="param-group">
        <label for="heightScale">Height Scale:</label>
        <input type="range" id="heightScale" min="1" max="50" value="20">
      </div>
      <div class="param-group">
        <label for="terrainFrequency">Frequency:</label>
        <input type="range" id="terrainFrequency" min="0.1" max="5.0" step="0.1" value="1.0">
      </div>
      <div class="param-group">
        <label for="terrainAmplitude">Amplitude:</label>
        <input type="range" id="terrainAmplitude" min="0.1" max="5.0" step="0.1" value="1.0">
      </div>
      <div class="param-group">
        <label for="terrainNoiseType">Noise Type:</label>
        <select id="terrainNoiseType">
          <option value="simplex">Simplex</option>
          <option value="perlin">Perlin</option>
          <option value="worley">Worley</option>
        </select>
      </div>
    </div>
  </section>
  
  <!-- AI Navigation Environment -->
  <section class="three-section" id="aiNav">
    <h2>AI Navigation Environment</h2>
    <div class="canvas-container" id="aiNavContainer">
      <!-- Debug overlay visible in debug mode -->
      <div id="debugOverlay" style="position:absolute; top:10px; right:10px; background:rgba(255,255,255,0.8); padding:10px; display:none; font-size:0.9rem; color:#000;"></div>
    </div>
    <div class="ai-controls">
      <button id="generateMaze">Generate Maze</button>
      <button id="spawnBlob">Spawn Blob</button>
      <button id="resetBlob">Reset Blob</button>
      <button id="resetMaze">Reset Maze</button>
      <button id="toggleDebug">Toggle Debug</button>
      <!-- New control for dynamic learning rate -->
      <label style="margin-left:10px; color:#00FF00; font-size:0.9rem;">
        <input type="checkbox" id="toggleDynamicLR" style="vertical-align:middle; margin-right:4px;">Dynamic Learning Rate
      </label>
      <div class="param-group" style="margin-top:10px;">
        <label for="learningMeter" style="color:#00FF00;">Learning Level:</label>
        <progress id="learningMeter" value="0" max="50" style="vertical-align:middle;"></progress>
      </div>
      <div class="param-group" style="margin-top:10px;">
        <label for="awarenessMeter" style="color:#00FF00;">Awareness Level:</label>
        <progress id="awarenessMeter" value="0" max="50" style="vertical-align:middle;"></progress>
      </div>
    </div>
  </section>
  
  <!-- About Section -->
  <section class="three-section" id="about">
    <h2>About This Site</h2>
    <p style="text-align:center; max-width:800px; margin:0 auto;">
      Game Dev Tech Ground is a retro-inspired experimental hub for interactive 3D demos and AI simulations.
      Enjoy a gritty early-internet vibe combined with modern 3D technology.
    </p>
  </section>
  
  <div id="easterEgg">
    <h2>ðŸŽ‰ Easter Egg Found! ðŸŽ‰</h2>
  <!-- Scripts -->
  
  <!-- Navigation Scroll Function -->

  <script type="module" src="ai_blob_rl.js"></script>
  <script>
    function scrollToSection(id) {
      document.getElementById(id).scrollIntoView({ behavior: "smooth" });
    }
  </script>
  
  <!-- Network Canvas Animation with Mouse Reaction -->
  <script>
    (function() {
      const canvas = document.getElementById("networkCanvas");
      const ctx = canvas.getContext("2d");
      let mousePos = { x: -9999, y: -9999 };
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
      });
      canvas.addEventListener("mouseleave", () => {
        mousePos.x = -9999;
        mousePos.y = -9999;
      });
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      const nodes = [];
      const numNodes = 200;
      const bound = 1000;
      for (let i = 0; i < numNodes; i++) {
        nodes.push({
          x: Math.random() * 2 * bound - bound,
          y: Math.random() * 2 * bound - bound,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
        });
      }
      const connectionDistance = 150;
      let lastTime = 0;
      function animate(time) {
        const deltaTime = time - lastTime;
        lastTime = time;
        nodes.forEach(node => {
          node.x += node.vx * deltaTime * 0.05;
          node.y += node.vy * deltaTime * 0.05;
          if (node.x < -bound) node.x = bound;
          if (node.x > bound) node.x = -bound;
          if (node.y < -bound) node.y = bound;
          if (node.y > bound) node.y = -bound;
        });
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        const hue = (time * 0.02) % 360;
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const dx = nodes[i].x - nodes[j].x;
            const dy = nodes[i].y - nodes[j].y;
            const dist = Math.hypot(dx, dy);
            if (dist < connectionDistance) {
              const alpha = 1 - dist / connectionDistance;
              ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha * 0.7})`;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(nodes[i].x, nodes[i].y);
              ctx.lineTo(nodes[j].x, nodes[j].y);
              ctx.stroke();
            }
          }
        }
        nodes.forEach(node => {
          let nodeColor = "rgba(0, 120, 215, 0.85)";
          let nodeRadius = 2;
          const nodeScreenX = node.x + canvas.width / 2;
          const nodeScreenY = node.y + canvas.height / 2;
          const dx = nodeScreenX - mousePos.x;
          const dy = nodeScreenY - mousePos.y;
          const distToMouse = Math.hypot(dx, dy);
          if (distToMouse < 100) {
            nodeColor = "rgba(255, 0, 0, 0.9)";
            nodeRadius = 4;
            ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(nodeScreenX, nodeScreenY);
            ctx.lineTo(mousePos.x, mousePos.y);
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
          ctx.fillStyle = nodeColor;
          ctx.shadowColor = "rgba(0, 120, 215, 0.8)";
          ctx.shadowBlur = 15;
          ctx.fill();
          ctx.shadowBlur = 0;
        });
        ctx.restore();
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    })();
  </script>
  
  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- 3D Cube Showcase Script -->
  <script>
    (function() {
      const container = document.getElementById("threeContainer");
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshStandardMaterial({
        color: 0x0078d7,
        metalness: 0.5,
        roughness: 0.1
      });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      const edges = new THREE.EdgesGeometry(geometry);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
      const outline = new THREE.LineSegments(edges, lineMaterial);
      cube.add(outline);
      const originalCube = {
        scale: cube.scale.clone(),
        rotation: cube.rotation.clone(),
        color: cube.material.color.getHex(),
        wireframe: cube.material.wireframe
      };
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(5, 5, 5);
      scene.add(pointLight);
      camera.position.set(3, 3, 3);
      camera.lookAt(scene.position);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      function animateCube() {
        requestAnimationFrame(animateCube);
        controls.update();
        renderer.render(scene, camera);
      }
      animateCube();
      window.addEventListener("resize", function() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
      function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
      }
      document.getElementById("modifier1").addEventListener("click", function() {
        const newScale = randomInRange(0.5, 2.0);
        cube.scale.set(newScale, newScale, newScale);
      });
      document.getElementById("modifier2").addEventListener("click", function() {
        cube.rotation.set(
          randomInRange(0, Math.PI * 2),
          randomInRange(0, Math.PI * 2),
          randomInRange(0, Math.PI * 2)
        );
      });
      document.getElementById("modifier3").addEventListener("click", function() {
        const randomColor = Math.floor(Math.random() * 0xffffff);
        cube.material.color.setHex(randomColor);
      });
      document.getElementById("modifier4").addEventListener("click", function() {
        cube.material.wireframe = !cube.material.wireframe;
      });
      document.getElementById("resetCube").addEventListener("click", function() {
        cube.scale.copy(originalCube.scale);
        cube.rotation.copy(originalCube.rotation);
        cube.material.color.setHex(originalCube.color);
        cube.material.wireframe = originalCube.wireframe;
      });
    })();
  </script>
  
  <!-- Boids Flocking Simulation Script -->
  <script>
    (function() {
      const container = document.getElementById("boidsContainer");
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      camera.position.set(0, 50, 100);
      camera.lookAt(0, 0, 0);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      scene.add(directionalLight);
      let perceptionRadius = parseFloat(document.getElementById("perceptionRadius").value);
      let alignmentWeight = parseFloat(document.getElementById("alignmentWeight").value);
      let cohesionWeight = parseFloat(document.getElementById("cohesionWeight").value);
      let separationWeight = parseFloat(document.getElementById("separationWeight").value);
      document.getElementById("perceptionRadius").addEventListener("input", function() {
        perceptionRadius = parseFloat(this.value);
      });
      document.getElementById("alignmentWeight").addEventListener("input", function() {
        alignmentWeight = parseFloat(this.value);
      });
      document.getElementById("cohesionWeight").addEventListener("input", function() {
        cohesionWeight = parseFloat(this.value);
      });
      document.getElementById("separationWeight").addEventListener("input", function() {
        separationWeight = parseFloat(this.value);
      });
      class Boid {
        constructor() {
          this.position = new THREE.Vector3(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50
          );
          this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2
          );
          this.acceleration = new THREE.Vector3(0, 0, 0);
          this.maxSpeed = 2;
          this.maxForce = 0.05;
          const geometry = new THREE.ConeGeometry(1, 4, 8);
          const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
          this.mesh = new THREE.Mesh(geometry, material);
          this.mesh.position.copy(this.position);
          this.mesh.rotation.x = Math.PI / 2;
          scene.add(this.mesh);
        }
        
        update(boids) {
          this.acceleration.set(0, 0, 0);
          let alignment = new THREE.Vector3();
          let cohesion = new THREE.Vector3();
          let separation = new THREE.Vector3();
          let total = 0;
          for (let other of boids) {
            if (other === this) continue;
            const d = this.position.distanceTo(other.position);
            if (d < perceptionRadius) {
              alignment.add(other.velocity);
              cohesion.add(other.position);
              let diff = new THREE.Vector3().subVectors(this.position, other.position);
              diff.divideScalar(d);
              separation.add(diff);
              total++;
            }
          }
          if (total > 0) {
            alignment.divideScalar(total);
            alignment.setLength(this.maxSpeed);
            alignment.sub(this.velocity);
            alignment.clampLength(0, this.maxForce);
            cohesion.divideScalar(total);
            cohesion.sub(this.position);
            cohesion.setLength(this.maxSpeed);
            cohesion.sub(this.velocity);
            cohesion.clampLength(0, this.maxForce);
            separation.divideScalar(total);
            separation.setLength(this.maxSpeed);
            separation.sub(this.velocity);
            separation.clampLength(0, this.maxForce);
            this.acceleration.add(alignment.multiplyScalar(alignmentWeight));
            this.acceleration.add(cohesion.multiplyScalar(cohesionWeight));
            this.acceleration.add(separation.multiplyScalar(separationWeight));
          }
          this.velocity.add(this.acceleration);
          this.velocity.clampLength(0, this.maxSpeed);
          this.position.add(this.velocity);
          const boundary = 100;
          if (this.position.x > boundary) this.position.x = -boundary;
          else if (this.position.x < -boundary) this.position.x = boundary;
          if (this.position.y > boundary) this.position.y = -boundary;
          else if (this.position.y < -boundary) this.position.y = boundary;
          if (this.position.z > boundary) this.position.z = -boundary;
          else if (this.position.z < -boundary) this.position.z = boundary;
          this.mesh.position.copy(this.position);
          if (this.velocity.length() > 0.01) {
            this.mesh.lookAt(this.position.clone().add(this.velocity));
          }
        }
      }
      
      let boids = [];
      const initialBoidCount = 30;
      for (let i = 0; i < initialBoidCount; i++) {
        boids.push(new Boid());
      }
      function updateBoidCount() {
        document.getElementById("boidCount").textContent = boids.length;
      }
      updateBoidCount();
      function animateBoids() {
        requestAnimationFrame(animateBoids);
        boids.forEach(boid => boid.update(boids));
        controls.update();
        renderer.render(scene, camera);
      }
      animateBoids();
      document.getElementById("resetBoids").addEventListener("click", function() {
        boids.forEach(boid => {
          scene.remove(boid.mesh);
          boid.mesh.geometry.dispose();
          boid.mesh.material.dispose();
        });
        boids = [];
        updateBoidCount();
      });
      document.getElementById("addBoid").addEventListener("click", function() {
        boids.push(new Boid());
        updateBoidCount();
      });
      window.addEventListener("resize", function() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    })();
  </script>
  
  <!-- Terrain Editor Script -->
  <script>
    (function() {
      const container = document.getElementById("terrainContainer");
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      let terrainMesh = null;
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 100, 50);
      scene.add(directionalLight);
      camera.position.set(0, 60, 100);
      camera.lookAt(0, 0, 0);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Perlin Noise implementation
      function perlinNoise(x, y, seed = 0) {
        x = (x + seed) % 256;
        y = (y + seed) % 256;
        let X = Math.floor(x) & 255,             // FIND INTEGER COORDINATES
            Y = Math.floor(y) & 255,
            x_fade = x - Math.floor(x),          // LEFT FADE
            y_fade = y - Math.floor(y),          // BOTTOM FADE
            // HASH COORDINATES OF THE VERTICES
            hash = new Uint8Array(256),
            p = new Uint8Array(512);
        for (let i = 0; i < 256; i++) {
          hash[i] = Math.floor(Math.random() * 256);
        }
        for (let i = 0; i < 512; i++) {
          p[i] = hash[i & 255];
        }
        // INTERPOLATE
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y, z) {
          let h = hash & 15;                      // CONVERT LO 4 BITS OF HASH CODE
          let u = h < 8 ? x : y,                 // into 12 gradient vectors
              v = h < 4 ? y : h == 12 || h == 14 ? x : z;
          return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
        }
        let n00 = grad(p[X + p[Y]], x_fade, y_fade, 0); // Top left corner
        let n01 = grad(p[X + p[Y + 1]], x_fade, y_fade - 1, 0); // Bottom left corner
        let n10 = grad(p[X + 1 + p[Y]], x_fade - 1, y_fade, 0); // Top right corner
        let n11 = grad(p[X + 1 + p[Y + 1]], x_fade - 1, y_fade - 1, 0); // Bottom right corner
        let x0 = lerp(fade(x_fade), n00, n10);
        let x1 = lerp(fade(x_fade), n01, n11);
        return lerp(fade(y_fade), x0, x1);
      }

      // Add this Worley noise fallback function in your Terrain Editor script
      function worleyNoise(x, y) {
        function randomVal(a, b) {
          return Math.abs(Math.sin(a * 12.9898 + b * 78.233) * 43758.5453) % 1;
        }
        let xi = Math.floor(x);
        let yi = Math.floor(y);
        let minDist = Infinity;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            let featureX = xi + i + randomVal(xi + i, yi + j);
            let featureY = yi + j + randomVal(yi + j, xi + i);
            let dx = x - featureX;
            let dy = y - featureY;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) minDist = dist;
          }
        }
        return minDist;
      }

      function generateHeightMap(size, roughness, frequency, amplitude, noiseType) {
        const heightMap = [];
        let noise;
        if (noiseType === 'simplex') {
          noise = new SimplexNoise();
        } else if (noiseType === 'perlin') {
          noise = {
            noise2D: (x, y) => perlinNoise(x * frequency, y * frequency)
          };
        } else if (noiseType === 'worley') {
          // Use the custom Worley fallback function
          noise = {
            get: (x, y) => worleyNoise(x * frequency, y * frequency)
          };
        }
        for (let x = 0; x < size; x++) {
          heightMap[x] = [];
          for (let y = 0; y < size; y++) {
            let elevation = 0;
            let freq = frequency;
            let amp = amplitude;
            for (let i = 0; i < 8; i++) {
              if (noiseType === 'simplex') {
                elevation += noise.noise2D((x / size) * freq, (y / size) * freq) * amp;
              } else if (noiseType === 'perlin') {
                elevation += noise.noise2D((x / size) * freq, (y / size) * freq) * amp;
              } else if (noiseType === 'worley') {
                elevation += noise.get((x / size) * freq, (y / size) * freq) * amp;
              }
              freq *= 2;
              amp *= roughness;
            }
            heightMap[x][y] = elevation;
          }
        }
        return heightMap;
      }

      function createTerrain() {
        if (terrainMesh) {
          scene.remove(terrainMesh);
          terrainMesh.geometry.dispose();
          terrainMesh.material.dispose();
          terrainMesh = null;
        }
        const size = parseInt(document.getElementById("terrainSize").value);
        const heightScale = parseFloat(document.getElementById("heightScale").value);
        const roughness = parseFloat(document.getElementById("terrainRoughness").value);
        const frequency = parseFloat(document.getElementById("terrainFrequency").value);
        const amplitude = parseFloat(document.getElementById("terrainAmplitude").value);
        const noiseType = document.getElementById("terrainNoiseType").value;
        
        const geometry = new THREE.PlaneGeometry(100, 100, size - 1, size - 1);
        let heightMap = generateHeightMap(size, roughness, frequency, amplitude, noiseType);
        const vertices = geometry.attributes.position.array;
        
        for (let i = 0; i < vertices.length; i += 3) {
          // Convert plane coordinates to heightMap grid coordinates
          const gridX = (vertices[i] + 50) / 100 * (size - 1);
          const gridY = (vertices[i + 1] + 50) / 100 * (size - 1);
          
          // Get the four surrounding grid indices
          const x0 = Math.floor(gridX);
          const y0 = Math.floor(gridY);
          const x1 = Math.min(x0 + 1, size - 1);
          const y1 = Math.min(y0 + 1, size - 1);
          
          // Compute the fractional part for interpolation
          const fracX = gridX - x0;
          const fracY = gridY - y0;
          
          // Retrieve the four corner height values
          const h00 = heightMap[x0][y0];
          const h10 = heightMap[x1][y0];
          const h01 = heightMap[x0][y1];
          const h11 = heightMap[x1][y1];
          
          // Bilinear interpolation
          const h0 = h00 * (1 - fracX) + h10 * fracX;
          const h1 = h01 * (1 - fracX) + h11 * fracX;
          const heightValue = h0 * (1 - fracY) + h1 * fracY;
          
          vertices[i + 2] = heightValue * heightScale;
        }
        
        geometry.computeVertexNormals();
        const material = new THREE.MeshPhongMaterial({
          color: 0x88ff88,
          wireframe: false,
          flatShading: true
        });
        terrainMesh = new THREE.Mesh(geometry, material);
        terrainMesh.rotation.x = -Math.PI / 2;
        scene.add(terrainMesh);
        
        document.getElementById("vertexCount").textContent = geometry.attributes.position.count;
        document.getElementById("triangleCount").textContent = geometry.index.count / 3;
      }

      document.getElementById("generateTerrain").addEventListener("click", createTerrain);
      document.getElementById("toggleWireframe").addEventListener("click", function() {
        if (terrainMesh) terrainMesh.material.wireframe = !terrainMesh.material.wireframe;
      });
      document.getElementById("resetTerrain").addEventListener("click", function() {
        document.getElementById("terrainSize").value = 64;
        document.getElementById("heightScale").value = 20;
        document.getElementById("terrainRoughness").value = 0.8;
        document.getElementById("terrainFrequency").value = 1.0;
        document.getElementById("terrainAmplitude").value = 1.0;
        document.getElementById("terrainNoiseType").value = 'simplex';
        createTerrain();
      });

      function animateTerrain() {
        requestAnimationFrame(animateTerrain);
        controls.update();
        renderer.render(scene, camera);
      }

      animateTerrain();
      createTerrain();
    })();
  </script>
  
  <!-- AI Navigation Environment Script -->
  <script>
    (function() {
      // Declare configuration variables first
      let dynamicLearningEnabled = false;
      const baseLearningRate = 0.1;
      const explorationRate = 0.2;
      
      // Global variable to toggle debug mode.
      let debugMode = false;
      const debugOverlay = document.getElementById("debugOverlay");

      const container = document.getElementById("aiNavContainer");
      let heatmapGroup = null; // Moved here, before buildMaze and createHeatmap

      const qTableCanvas = document.createElement("canvas");
      qTableCanvas.style.position = "absolute";
      qTableCanvas.style.top = "0";
      qTableCanvas.style.left = "0";
      qTableCanvas.style.pointerEvents = "none";
      qTableCanvas.width = container.clientWidth;
      qTableCanvas.height = container.clientHeight;
      container.appendChild(qTableCanvas);
      const qTableCtx = qTableCanvas.getContext("2d");

      function updateQTableOverlay() {
        qTableCtx.clearRect(0, 0, qTableCanvas.width, qTableCanvas.height);
        
        const cellWidth = qTableCanvas.width / mazeCols;
        const cellHeight = qTableCanvas.height / mazeRows;
        
        for (let r = 0; r < mazeRows; r++) {
          for (let c = 0; c < mazeCols; c++) {
            const stateKey = `${c},${r},${Math.floor(finishMarker.position.x / cellSize)},${Math.floor(finishMarker.position.z / cellSize)}`;
            let maxQ = 0;
            if (blob && blob.userData.qTable[stateKey]) {
              maxQ = Math.max(...Object.values(blob.userData.qTable[stateKey]));
            }
            const intensity = Math.min(255, Math.floor(maxQ * 50));
            qTableCtx.fillStyle = `rgba(0,${intensity},0,0.3)`;
            qTableCtx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
          }
        }
      }

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      camera.position.set(0, 50, 150);
      camera.lookAt(0, 0, 0);
      
      // Maze variables
      const cellSize = 10;
      let mazeRows = 10, mazeCols = 10;
      let mazeGrid = [];
      let mazeGroup = new THREE.Group();
      let finishMarker = null;
      
      // Blob (AI agent)
      let blob = null;
      let blobStart = new THREE.Vector3();
      
      // New global variable to track visit counts for each maze cell.
      let visitCounts = [];

      // Maze generator (recursive backtracking)
      function generateMaze(rows, cols) {
        let grid = [];
        for (let r = 0; r < rows; r++) {
          let row = [];
          for (let c = 0; c < cols; c++) {
            row.push({
              row: r,
              col: c,
              walls: { top: true, right: true, bottom: true, left: true },
              visited: false
            });
          }
          grid.push(row);
        }
        function getUnvisitedNeighbors(cell) {
          let neighbors = [];
          let { row, col } = cell;
          if (row > 0 && !grid[row - 1][col].visited) neighbors.push(grid[row - 1][col]);
          if (col < cols - 1 && !grid[row][col + 1].visited) neighbors.push(grid[row][col + 1]);
          if (row < rows - 1 && !grid[row + 1][col].visited) neighbors.push(grid[row + 1][col]);
          if (col > 0 && !grid[row][col - 1].visited) neighbors.push(grid[row][col - 1]);
          return neighbors;
        }
        function removeWalls(current, next) {
          let x = current.col - next.col;
          let y = current.row - next.row;
          if (x === 1) { current.walls.left = false; next.walls.right = false; }
          else if (x === -1) { current.walls.right = false; next.walls.left = false; }
          if (y === 1) { current.walls.top = false; next.walls.bottom = false; }
          else if (y === -1) { current.walls.bottom = false; next.walls.top = false; }
        }
        let stack = [];
        let current = grid[0][0];
        current.visited = true;
        while (true) {
          let neighbors = getUnvisitedNeighbors(current);
          if (neighbors.length > 0) {
            let next = neighbors[Math.floor(Math.random() * neighbors.length)];
            stack.push(current);
            removeWalls(current, next);
            next.visited = true;
            current = next;
          } else if (stack.length > 0) {
            current = stack.pop();
          } else {
            break;
          }
        }
        return grid;
      }
      
      // Call this inside buildMaze() after the maze grid is recreated:
      function initializeVisitCounts() {
        visitCounts = [];
        for (let r = 0; r < mazeRows; r++) {
          const row = [];
          for (let c = 0; c < mazeCols; c++) {
            row.push(0);
          }
          visitCounts.push(row);
        }
      }

      // Modify buildMaze(): (Insert initializeVisitCounts() at the end)
      function buildMaze() {
        if (mazeGroup) {
          scene.remove(mazeGroup);
          mazeGroup.traverse(child => {
            if (child.isMesh) {
              child.geometry.dispose();
              child.material.dispose();
            }
          });
          mazeGroup = new THREE.Group();
        }
        mazeGrid = generateMaze(mazeRows, mazeCols);
        for (let r = 0; r < mazeRows; r++) {
          for (let c = 0; c < mazeCols; c++) {
            let cell = mazeGrid[r][c];
            let x = c * cellSize;
            let z = r * cellSize;
            let wallThickness = 1;
            let wallHeight = 10;
            if (cell.walls.top) {
              let geom = new THREE.BoxGeometry(cellSize, wallHeight, wallThickness);
              let mat = new THREE.MeshBasicMaterial({ color: 0x888888 });
              let wall = new THREE.Mesh(geom, mat);
              wall.position.set(x + cellSize/2, wallHeight/2, z);
              mazeGroup.add(wall);
            }
            if (cell.walls.right) {
              let geom = new THREE.BoxGeometry(wallThickness, wallHeight, cellSize);
              let mat = new THREE.MeshBasicMaterial({ color: 0x888888 });
              let wall = new THREE.Mesh(geom, mat);
              wall.position.set(x + cellSize, wallHeight/2, z + cellSize/2);
              mazeGroup.add(wall);
            }
            if (cell.walls.bottom) {
              let geom = new THREE.BoxGeometry(cellSize, wallHeight, wallThickness);
              let mat = new THREE.MeshBasicMaterial({ color: 0x888888 });
              let wall = new THREE.Mesh(geom, mat);
              wall.position.set(x + cellSize/2, wallHeight/2, z + cellSize);
              mazeGroup.add(wall);
            }
            if (cell.walls.left) {
              let geom = new THREE.BoxGeometry(wallThickness, wallHeight, cellSize);
              let mat = new THREE.MeshBasicMaterial({ color: 0x888888 });
              let wall = new THREE.Mesh(geom, mat);
              wall.position.set(x, wallHeight/2, z + cellSize/2);
              mazeGroup.add(wall);
            }
          }
        }
        // Outer boundaries
        let outerGeom1 = new THREE.BoxGeometry(mazeCols * cellSize, 10, 1);
        let outerWall1 = new THREE.Mesh(outerGeom1, new THREE.MeshBasicMaterial({ color: 0x888888 }));
        outerWall1.position.set((mazeCols * cellSize)/2, 5, 0);
        mazeGroup.add(outerWall1);
        let outerGeom2 = new THREE.BoxGeometry(mazeCols * cellSize, 10, 1);
        let outerWall2 = new THREE.Mesh(outerGeom2, new THREE.MeshBasicMaterial({ color: 0x888888 }));
        outerWall2.position.set((mazeCols * cellSize)/2, 5, mazeRows * cellSize);
        mazeGroup.add(outerWall2);
        let outerGeom3 = new THREE.BoxGeometry(1, 10, mazeRows * cellSize);
        let outerWall3 = new THREE.Mesh(outerGeom3, new THREE.MeshBasicMaterial({ color: 0x888888 }));
        outerWall3.position.set(0, 5, (mazeRows * cellSize)/2);
        mazeGroup.add(outerWall3);
        let outerGeom4 = new THREE.BoxGeometry(1, 10, mazeRows * cellSize);
        let outerWall4 = new THREE.Mesh(outerGeom4, new THREE.MeshBasicMaterial({ color: 0x888888 }));
        outerWall4.position.set(mazeCols * cellSize, 5, (mazeRows * cellSize)/2);
        mazeGroup.add(outerWall4);
        mazeGroup.position.x = - (mazeCols * cellSize) / 2;
        mazeGroup.position.z = - (mazeRows * cellSize) / 2;
        scene.add(mazeGroup);
        // Set blob starting position at cell (0,0)
        blobStart.set(cellSize/2, 2, cellSize/2);
        spawnFinishMarker();
        // Initialize visit counts for the new maze.
        initializeVisitCounts();
        createHeatmap();
        // Instead of directly calling updateMazeMaterials(mazeGroup);
        if (window.updateMazeMaterials) {
            window.updateMazeMaterials(mazeGroup);
        }
      }
      
      function spawnFinishMarker() {
        // Remove old finish marker if exists
        if (finishMarker) {
          scene.remove(finishMarker);
          finishMarker.geometry.dispose();
          finishMarker.material.dispose();
          finishMarker = null;
        }
        // Choose a random cell (not the start cell)
        let finishRow = Math.floor(Math.random() * mazeRows);
        let finishCol = Math.floor(Math.random() * mazeCols);
        if (finishRow === 0 && finishCol === 0) {
          finishRow = mazeRows - 1;
          finishCol = mazeCols - 1;
        }
        let x = finishCol * cellSize + cellSize / 2;
        let z = finishRow * cellSize + cellSize / 2;
        finishMarker = new THREE.Mesh(
          new THREE.SphereGeometry(2, 16, 16),
          new THREE.MeshBasicMaterial({ color: 0x00FF00 })
        );
        finishMarker.position.set(x - (mazeCols * cellSize) / 2, 2, z - (mazeRows * cellSize) / 2);
        scene.add(finishMarker);
      }
      
      // Declare a global variable to hold the ghost trail line.
      let ghostTrailLine = null;

      function spawnBlob() {
        if (blob) {
          scene.remove(blob);
          blob.geometry.dispose();
          blob.material.dispose();
          blob = null;
        }
        let geometry = new THREE.SphereGeometry(2, 16, 16);
        let material = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        blob = new THREE.Mesh(geometry, material);
        blob.position.copy(blobStart);
        blob.userData.velocity = new THREE.Vector3(1, 0, 0).normalize().multiplyScalar(1.5);
        blob.userData.maxSpeed = 3;
        blob.userData.qTable = {};
        blob.userData.state = `${Math.floor(blob.position.x / cellSize)},${Math.floor(blob.position.z / cellSize)},${Math.floor(finishMarker.position.x / cellSize)},${Math.floor(finishMarker.position.z / cellSize)}`;
        blob.userData.score = 0;
        // Initialize the ghost trail array.
        blob.userData.trail = [];
        scene.add(blob);
      }
      
      function resetBlob() {
        if (blob) {
          blob.position.copy(blobStart);
          blob.userData.velocity.set(1, 0, 0).normalize().multiplyScalar(1.5);
        }
      }
      // Place these at the top of your IIFE to ensure they're defined before any function uses them.
      // let dynamicLearningEnabled = false;
      // const baseLearningRate = 0.1;
      // const explorationRate = 0.2;

      function updateBlob(delta) {
        if (!blob) return; // Ensure blob is defined before updating

        // Q-learning parameters
        const discountFactor = 0.9;
        const learningRate = dynamicLearningEnabled
          ? baseLearningRate * (1 / (1 + (blob.userData.score || 0) / 10))
          : baseLearningRate;

        // Get current state
        const currentState = `${Math.floor(blob.position.x / cellSize)},${Math.floor(blob.position.z / cellSize)},${Math.floor(finishMarker.position.x / cellSize)},${Math.floor(finishMarker.position.z / cellSize)}`;

        // Get possible actions
        const actions = [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(-1, 0, 0),
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 0, -1)
        ];

        // Choose action
        let action;
        if (Math.random() < explorationRate || !blob.userData.qTable[currentState]) {
          action = actions[Math.floor(Math.random() * actions.length)];
        } else {
          action = actions.reduce((bestAction, currentAction) => {
            const qValue = blob.userData.qTable[currentState][currentAction.toArray().toString()] || 0;
            const bestQValue = blob.userData.qTable[currentState][bestAction.toArray().toString()] || 0;
            return qValue > bestQValue ? currentAction : bestAction;
          }, actions[0]);
        }

        // Apply action
        blob.userData.velocity.add(action).normalize().multiplyScalar(blob.userData.maxSpeed || 3);
        blob.position.add(blob.userData.velocity.clone().multiplyScalar(delta));

        // Get new state
        const newState = `${Math.floor(blob.position.x / cellSize)},${Math.floor(blob.position.z / cellSize)},${Math.floor(finishMarker.position.x / cellSize)},${Math.floor(finishMarker.position.z / cellSize)}`;

        // Calculate reward
        let reward = -0.01; // Step penalty
        const distanceToGoal = blob.position.distanceTo(finishMarker.position);

        // Declare dotProduct variable here so it's available later.
        let dotProduct = 0;

        if (distanceToGoal < 5) {
          reward = 10; // Reward for reaching the goal
          resetBlob();
          spawnFinishMarker();
        } else {
          // Check if blob is moving in the right direction toward the finish marker.
          const toGoal = new THREE.Vector3().subVectors(finishMarker.position, blob.position).normalize();
          const velocityNorm = blob.userData.velocity.clone().normalize();
          dotProduct = velocityNorm.dot(toGoal);
          // Bonus reward for being well-oriented.
          if (dotProduct > 0.8) {
            reward += 0.1;
          }
          // Check collision with maze walls...
          let blobBox = new THREE.Box3().setFromObject(blob);
          let collided = false;
          for (let wall of mazeGroup.children) {
            let wallBox = new THREE.Box3().setFromObject(wall);
            if (blobBox.intersectsBox(wallBox)) {
              reward = -0.5; // Penalty for hitting a wall
              resetBlob();
              collided = true;
              break;
            }
          }
          // Use a raycaster to detect a wall ahead if no collision occurred.
          if (!collided) {
            const raycaster = new THREE.Raycaster(blob.position, blob.userData.velocity.clone().normalize());
            const intersections = raycaster.intersectObjects(mazeGroup.children);
            if (intersections.length > 0 && intersections[0].distance < cellSize) {
              reward -= 0.2;
            }
          }
        }

        // Update Q-table
        if (!blob.userData.qTable[currentState]) {
          blob.userData.qTable[currentState] = {};
        }
        if (!blob.userData.qTable[newState]) {
          blob.userData.qTable[newState] = {};
        }
        const oldQValue = blob.userData.qTable[currentState][action.toArray().toString()] || 0;
        const maxFutureQValue = Math.max(...actions.map(a => blob.userData.qTable[newState][a.toArray().toString()] || 0));
        const newQValue = oldQValue + learningRate * (reward + discountFactor * maxFutureQValue - oldQValue);
        blob.userData.qTable[currentState][action.toArray().toString()] = newQValue;

        // Update blob state
        blob.userData.state = newState;

        // Update visit counts for visualization.
        let colIndex = Math.floor((blob.position.x + (mazeCols * cellSize) / 2) / cellSize);
        let rowIndex = Math.floor((blob.position.z + (mazeRows * cellSize) / 2) / cellSize);
        if (rowIndex >= 0 && rowIndex < mazeRows && colIndex >= 0 && colIndex < mazeCols) {
          visitCounts[rowIndex][colIndex]++;
        }

        // Record the blob's current position for the ghost trail.
        if (!blob.userData.trail) blob.userData.trail = [];
        blob.userData.trail.push(blob.position.clone());
        if (blob.userData.trail.length > 50) {
          blob.userData.trail.shift();
        }

        // Update score
        if (reward > 0) {
          blob.userData.score = (blob.userData.score || 0) + reward;
        } else {
          blob.userData.score = Math.max(0, (blob.userData.score || 0) + reward);
        }
        document.getElementById("learningMeter").value = Math.min(blob.userData.score, 50);

        // Compute awareness based on dotProduct and update the awareness meter.
        const awarenessValue = Math.floor(Math.max(0, Math.min(1, dotProduct)) * 50);
        document.getElementById("awarenessMeter").value = awarenessValue;

        updateHeatmap();
        updateDebugInfo();
      }

      // New function to update and render the ghost trail:
      function updateGhostTrail() {
        if (!blob || !blob.userData.trail) return;
        
        // Remove the old trail line if it exists.
        if (ghostTrailLine) {
          scene.remove(ghostTrailLine);
          ghostTrailLine.geometry.dispose();
          ghostTrailLine.material.dispose();
          ghostTrailLine = null;
        }
        
        // Create geometry from the trail points.
        const trailGeometry = new THREE.BufferGeometry().setFromPoints(blob.userData.trail);
        const trailMaterial = new THREE.LineBasicMaterial({
          color: 0xff00ff,
          linewidth: 2,
          transparent: true,
          opacity: 0.5
        });
        ghostTrailLine = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(ghostTrailLine);
      }

      let clock = new THREE.Clock();
      function animateAINav() {
        requestAnimationFrame(animateAINav);
        let delta = clock.getDelta();
        if (window.updateReactiveMaterial) {
          window.updateReactiveMaterial(delta);
        }
        updateBlob(delta);
        updateGhostTrail();
        updateQTableOverlay();  // Updated once per frame.
        controls.update();
        renderer.render(scene, camera);
      }

      document.getElementById("generateMaze").addEventListener("click", buildMaze);
      document.getElementById("spawnBlob").addEventListener("click", spawnBlob);
      document.getElementById("resetBlob").addEventListener("click", resetBlob);
      document.getElementById("resetMaze").addEventListener("click", function() {
        if (blob) {
          scene.remove(blob);
          blob.geometry.dispose();
          blob.material.dispose();
          blob = null;
        }
        if (mazeGroup) {
          scene.remove(mazeGroup);
          mazeGroup.traverse(child => {
            if (child.isMesh) {
              child.geometry.dispose();
              child.material.dispose();
            }
          });
          mazeGroup = new THREE.Group();
        }
      });

      buildMaze();
      animateAINav();
      window.addEventListener("resize", function() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      function createHeatmap() {
        if (heatmapGroup) {
          scene.remove(heatmapGroup);
          heatmapGroup.traverse(child => {
            if (child.isMesh) {
              child.geometry.dispose();
              child.material.dispose();
            }
          });
        }
        heatmapGroup = new THREE.Group();
        // Create a heatmap plane for each maze cell.
        for (let r = 0; r < mazeRows; r++) {
          for (let c = 0; c < mazeCols; c++) {
            let geometry = new THREE.PlaneGeometry(cellSize, cellSize);
            let material = new THREE.MeshBasicMaterial({
              color: 0x0000ff,
              transparent: true,
              opacity: 0.5,
              side: THREE.DoubleSide
            });
            let plane = new THREE.Mesh(geometry, material);
            // Position the plane over the corresponding cell.
            plane.position.set(
              c * cellSize + cellSize / 2 - (mazeCols * cellSize) / 2,
              11, // Height slightly above the maze walls (wall height is 10)
              r * cellSize + cellSize / 2 - (mazeRows * cellSize) / 2
            );
            plane.rotation.x = -Math.PI / 2;
            heatmapGroup.add(plane);
          }
        }
        scene.add(heatmapGroup);
      }

      // New updateHeatmap() that uses visitCounts instead of Qâ€‘values:
      function updateHeatmap() {
        if (!blob || !heatmapGroup) return;
        
        // Determine the maximum visit count to normalize the intensity.
        let maxVisits = 0;
        for (let r = 0; r < mazeRows; r++) {
          for (let c = 0; c < mazeCols; c++) {
            if (visitCounts[r][c] > maxVisits) {
              maxVisits = visitCounts[r][c];
            }
          }
        }
        
        // Update each heatmap planeâ€™s color (blue for low visits, red for high).
        heatmapGroup.children.forEach((plane, idx) => {
          let c = idx % mazeCols;
          let r = Math.floor(idx / mazeCols);
          let count = visitCounts[r][c];
          let intensity = maxVisits > 0 ? count / maxVisits : 0;
          let red = intensity;      // more visits â†’ redder
          let blue = 1 - intensity; // fewer visits â†’ bluer
          plane.material.color.setRGB(red, 0, blue);
        });
      }

      // Global variable to toggle debug mode.
      // let debugMode = false;
      // const debugOverlay = document.getElementById("debugOverlay");

      // New global variable for dynamic learning rate.
      // let dynamicLearningEnabled = false;
      // const baseLearningRate = 0.1;
      // const explorationRate = 0.2;

      // Toggle dynamic learning via the new checkbox.
      document.getElementById("toggleDynamicLR").addEventListener("change", function(e) {
        dynamicLearningEnabled = e.target.checked;
      });

      // Modify your blob parameters by adding, for example, a new random speed modifier:
      function randomizeBlobSpeed() {
        if (blob) {
          const newSpeed = Math.random() * 2 + 1; // new speed between 1 and 3
          blob.userData.maxSpeed = newSpeed;
        }
      }

      // Add event listener for the debug toggle button.
      document.getElementById("toggleDebug").addEventListener("click", function() {
        debugMode = !debugMode;
        debugOverlay.style.display = debugMode ? "block" : "none";
      });
      
      // Optionally add a new button for the blob modifier.
      // e.g., You could add a "Randomize Speed" button in the AI controls.
      // Note: Add the button in HTML and then handle it here.
      // Example (if added):
      // document.getElementById("randomizeBlobSpeed").addEventListener("click", randomizeBlobSpeed);

      // Function to update the debug overlay information.
      function updateDebugInfo() {
        if (debugMode) {
          if (blob) {
            const currentLearningRate = dynamicLearningEnabled
              ? baseLearningRate * (1 / (1 + (blob.userData.score || 0) / 10))
              : baseLearningRate;
            debugOverlay.innerHTML = `
              <strong>Blob Debug Info</strong><br>
              Position: (${blob.position.x.toFixed(2)}, ${blob.position.y.toFixed(2)}, ${blob.position.z.toFixed(2)})<br>
              Velocity: (${blob.userData.velocity.x.toFixed(2)}, ${blob.userData.velocity.y.toFixed(2)}, ${blob.userData.velocity.z.toFixed(2)})<br>
              State: ${blob.userData.state}<br>
              Score: ${blob.userData.score || 0}<br>
              Learning Rate: ${currentLearningRate.toFixed(3)}<br>
              Exploration Rate: ${explorationRate}
            `;
          } else {
            debugOverlay.innerHTML = `<strong>Debug Info:</strong><br>Blob not spawned.`;
          }
        }
      }
    })();
  </script>
  
  <script>
    document.addEventListener('keydown', function(event) {
      if (event.ctrlKey && event.shiftKey && event.key === 'E') {
        document.getElementById('easterEgg').style.display = 'block';
      }
    });
  </script>

  <script>
    (function() {
      // Define custom shader for maze walls.
      const vertexShader = /* glsl */`
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `;

      const fragmentShader = /* glsl */`
        uniform float time;
        uniform float visitIntensity;
        uniform vec3 baseColor;
        varying vec2 vUv;
        void main() {
          // Generate a dynamic effect based on UVs, time, and visit intensity.
          float effect = sin(vUv.x * 10.0 + time) * cos(vUv.y * 10.0 + time);
          effect = effect * 0.5 + 0.5;
          // Mix base color with a red tint when visitIntensity is high.
          vec3 dynamicColor = mix(baseColor, vec3(1.0, 0.0, 0.0), visitIntensity);
          gl_FragColor = vec4(dynamicColor * effect, 1.0);
        }
      `;

      // Create the shader material.
      const reactiveMaterial = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        uniforms: {
          time: { value: 0 },
          visitIntensity: { value: 0 },  // This could be tailored to cell visit count.
          baseColor: { value: new THREE.Color(0x888888) }
        }
      });

      // Function to assign the reactive material to maze walls.
      function updateMazeMaterials(mazeGroup) {
        mazeGroup.traverse(child => {
          if (child.isMesh) {
            child.material = reactiveMaterial;
          }
        });
      }

      // Hook into your render loop to update the time uniform.
      function updateReactiveMaterial(delta) {
        reactiveMaterial.uniforms.time.value += delta;
        // Optionally, update visitIntensity, perhaps averaging visit counts across cells.
        // For example:
        // reactiveMaterial.uniforms.visitIntensity.value = someCalculatedValue;
      }

      // Expose these functions to use in your existing maze generation flow.
      window.updateReactiveMaterial = updateReactiveMaterial;
      window.updateMazeMaterials = updateMazeMaterials;
    })();
  </script>
</body>
</html>
